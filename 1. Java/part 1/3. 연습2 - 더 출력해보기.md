# 목차

- [목차](#목차)
- [연습2 - 더 출력해보기](#연습2---더-출력해보기)
- [1. 해보자](#1-해보자)
  - [1.1. 정수 리터럴(Integer literal)](#11-정수-리터럴integer-literal)
  - [1.2. 실수 리터럴(Floating-point literal)](#12-실수-리터럴floating-point-literal)
  - [1.3. 문자 리터럴(Character literal)](#13-문자-리터럴character-literal)
  - [1.4. 문자열 리터럴(String literal)](#14-문자열-리터럴string-literal)
  - [1.5. 논리 리터럴(Boolean literal)](#15-논리-리터럴boolean-literal)
- [2. 더 해보자](#2-더-해보자)
- [3. 생각 해보기](#3-생각-해보기)

# 연습2 - 더 출력해보기

지난 시간에 배운 것에 대해서 생각해보자.  

- 패키지와 클래스 생성
- 문자열 리터럴
- System.out.println
- 코드 망가뜨려서 에러 메세지 확인

이번 시간에는 `exer2`라는 이름의 패키지를 생성하고, `Exercise2`라는 이름의 클래스를 생성해서 실습을 준비해보자.  

# 1. 해보자

지난 시간에 출력해본 것은 글이였다. 그렇다면 숫자를 출력하려면 어떻게 해야할 까?  

```java
System.out.println("12345678901234");
System.out.println("3.1415926535");
```

이게 맞을까? 여러분이 출력한 이것은 여전히 `문자열`이다.  

여러분이 `println`이라는 함수(메소드)에 전달한 `문자열`은 `값`, 즉 `데이터`이다.  
이 데이터에는 종류가 있다. 지난 시간에 공부한 `문자열 리터럴`도 데이터의 한 종류이다.  

리터럴은 상수 값(데이터) 자체를 의미한다. 이번 시간에는 리터럴의 종류에 대해 알아보고 출력해보는 시간을 갖도록 할 것이다.  
리터럴의 종류는 다음과 같다.  

- 정수 리터럴(Integer literal)
- 실수 리터럴(Floating-point literal)
- 문자 리터럴(Character literal)
- 문자열 리터럴(String literal)
- 논리 리터럴(Boolean literal)

낯선 단어가 어렵게 느껴지겠지만 모르는거지 어려운게 아니므로 진행해보자.  

## 1.1. 정수 리터럴(Integer literal)

정수는 우리가 아는 그 정수가 맞다. 정수는 음의 정수, 0, 양의 정수가 있다.  

- 음의 정수: -1, -2, -3, ...
- 0(정수): 0
- 양의 정수: 1, 2, 3, ...

코드에서는 어떻게 표시할까?  

```java
System.out.println(-1);
System.out.println(0);
System.out.println(1);
```

맥빠지게 쉽다. 다만 주의할 점은 컴퓨터에서 사용하는 숫자는 모두 범위가 있다. 왜냐하면 메모리 공간이 유한하기 때문인데 이는 나중에 자세히 다뤄본다.  

## 1.2. 실수 리터럴(Floating-point literal)

수학적인 정의를 떠나서 직관적으로 보자. 0과 1 사이에 있는 수. `.xxx`로 표현되는 그 수를 의미한다.  

```java
System.out.println(3.141592);
System.out.println(2.718281);
```

다만 앞서 언급한 바와 같이 이 친구 또한 무한하게 쓸 수는 없다.  
또한 컴퓨터에서 사용하는 실수에는 오차가 **반드시** 존재하기 때문에 추가적으로 `정밀도(precision)`라는 개념이 추가된다.  

## 1.3. 문자 리터럴(Character literal)

문자열 리터럴을 배운 여러분은 당당하게 "`"A"`와 같이 표현하면 되는 것 아닌가?"라고 생각을 할 것이다.  
아니기 때문에 따로 이렇게 소개를 하는 것이다. 

문자열 리터럴과 달리 `문자 리터럴`은 작은 따옴표로 `'A'` 감싸서 표현하며 단 **한 글자만 저장**할 수 있다.  

```java
System.out.println('A');
System.out.println('가');
System.out.println('あ');
```

영어 뿐만 아니라 인간 언어의 문자면 다 된다.  

## 1.4. 문자열 리터럴(String literal)

이미 여러분은 문자열 리터럴에 대해 굉장히 잘 알고 있다.  
특징만 정리해보고 실습은 각자 해보자.  

- 큰 따옴표(`"`)로 감싸서 표현한다.
- 문자열은 문자의 열(시퀀스)이다.
- 메모리가 허락하는 만큼만 쓸 수 있다.

## 1.5. 논리 리터럴(Boolean literal)

앞서 소개한 데이터들과 같이 여러분이 친하게 알고 지내던 것들과 명확하게 구분되는 것이 바로 이 논리 리터럴이다.  

이 리터럴은 참과 거짓만 존재하며 다음과 같이 표현한다.  

```java
System.out.println(true);
System.out.println(false);
```

간단하게 `true`와 `false`라는 값이 컴퓨터에 있구나. 정도만 기억해도 된다.  

# 2. 더 해보자

자. 이제 다른 종류의 리터럴이 존재한다는 것을 알았다. 또, 문자열 리터럴과 같이 다른 리터럴도 `println`을 통해 출력 가능하다는 사실을 파악하였다.  

이제 이런 생각을 해볼 수 있다. 여러 종류의 데이터들을 한 줄에 같이 쓸 수는 없을까? 이를 알아보기 위해 다음의 출력을 생각해보자.  

```text
1. 올해는? 2021년
2. 현재 환율은? 1달러 = 1103.05원
3. 원주율은?(소수점 5자리) 3.14159
```

이를 코드로 출력하기 위해 다음과 같은 방법을 사용할 수 있다.  

```java
System.out.println("1. 올해는? " + 2021 + "년");
System.out.println("2. 현재 환율은? 1달러 = " + 1103.05 + "원");
System.out.println("3. 원주율은?(소수점 5자리) " + 3.14159);
```

지금까지 알던 덧셈 기호(+)는 두 수를 더하는 것이였다.  
자바에서는 `문자열 리터럴`과 앞서 공부한 다른 리터럴을 더하면 다른 리터럴은 문자열로 변경되고 난 후 서로 연결된다. 여기서 `+`는 문자열 연결 연산자이다.  

사용을 해보자면 다음과 같다.  

```java
"1. 올해는? " + 2021 + "년"
"1. 올해는? 2021년"
```

그럼 애초에 아래와 같이 표현하지 왜 굳이 저렇게 표현할까?  
수는 변하기 때문이다. 원주율을 제외한 연도, 환율은 시간이 흐름에 따라 변한다. 변할 때 마다 프로그램의 코드를 바꾸고 다시 실행시키는 것은 비효율 적이다. 연도는 다음과 같은 코드로 표현할 수 있다.  

```java
LocalDateTime now = LocalDateTime.now();
System.out.println("1. 올해는? " + now.getYear() + "년");
```

이렇게 하면 연도가 바뀔 때 숫자를 바꿀 필요 없이 계속 유지 가능하다. now는 현재 시간 정보를 담당하는 친구이다. 이 친구에게 현재 연도를 물어보면 현재 시간의 연도를 답해주기 때문에 우리가 처음에 작성한 코드를 수정할 필요가 없다.  

# 3. 생각 해보기

앞의 예제에선 단지 두 개의 리터럴만 연결하였기 때문에 불편함을 느끼지 못했지만, 여러 리터럴을 연결하는 경우에는 불편해질 수 있다.  

이런 경우에 유용한 `포맷 스트링(Format String)`이라는 것이 존재한다. 일반적인 문자열과 동일하지만 서식(format)을 위한 규칙들이 존재한다. 
또한 다른점은 `println`이 아닌 `printf`를 사용해야한다. 끝의 f는 `format`을 의미한다.  

앞서 했던 예제를 수정해보겠다.  

```java
LocalDateTime now = LocalDateTime.now();
System.out.printf("1. 올해는? %d년", now.getYear());
System.out.printf("2. 현재 환율은? 1달러 = %.2f원", 1103.05);
System.out.printf("3. 원주율은?(소수점 5자리) %.5f", 3.14159);
```

여기서 %로 시작하는 친구가 바로 format이다. 서식의 종류는 다음과 같다.  

|서식|설명|
|-|-|
|%s|문자열(string)|
|%f|소수(floating-point)|
|%d|10진수 정수(decimal)|
|%x|16진수 정수(hexadecimal)|
|%o|8진수 정수(octal)|

소수는 조금 특별한데, `%.`와 `f` 사이에 자리 수를 지정할 수 있다.  

여러 포맷도 지정할 수 있다.  

```java
LocalDateTime now = LocalDateTime.now();
System.out.printf("Year: %d, pi: %.2f", now.getYear(), 3.14159);
```

`printf` 함수에는 3개의 값이 넘어갔다. 순서대로 나타내면 다음과 같다.  

1. "Year: %d, pi: %.2f"
2. now.getYear()
3. 3.14159

첫 번째 값은 포맷이 들어있는 문자열 리터럴  
두 번째 값은 올해 연도를 나타내는 값  
세 번째 값은 원주율인 3.141592  

문자열에 들어있는 포맷은 `%d`와 `%.2f`이며 각각 두 번째와 세 번째 값들과 매핑되어 치환된다.  

그럼 여기서 중한 내용을 요약하면 뭘까?  

- printf로 출력하면 새 줄에 출력되는 것이 아니라는 점

ㄴㅇㄱ