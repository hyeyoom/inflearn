# 목차

- [목차](#목차)
- [이론1 - 수와 타입](#이론1---수와-타입)
- [1. CPU와 메모리](#1-cpu와-메모리)
- [2. 컴퓨터의 수 표현](#2-컴퓨터의-수-표현)
  - [2.1. 10진법 <-> 2진법 변환](#21-10진법---2진법-변환)
- [3. 음수를 표현하는 방법](#3-음수를-표현하는-방법)
  - [3.1. 1의 보수를 사용하기](#31-1의-보수를-사용하기)
  - [3.2. 2의 보수를 사용하기](#32-2의-보수를-사용하기)
- [4. 실수 표현 방법](#4-실수-표현-방법)
- [5. 문자 표현](#5-문자-표현)

# 이론1 - 수와 타입

지난 시간에 배운 것들의 이론적 배경을 이번 시간에 학습한다. 정리하지 않았던 값의 표현 범위, 정밀도, 유니코드 등에 대해 학습할 것이다. 지루한 편이므로 가벼운 마음으로 듣자.  

여기서 학습할 내용은 다음과 같다.  

1. CPU와 메모리
2. 진법
3. 2의 보수
4. 실수 표현 방법
5. 문자표현

하나하나 알아보자.  

# 1. CPU와 메모리

CPU와 메모리의 역할에 대해서 간단히 다룬다.  

# 2. 컴퓨터의 수 표현

사람은 열 손가락을 이용해 숫자를 셀 수 있다. 우리가 다루는 숫자의 특징을 생각해보자. 열 개가 되면 (자리)올림이 발생한다.  

숫자 123을 생각해보자.  

100은 올림이 2번 발생한 수이다. 자리 올림이 2번 발생한 수가 1묶음 있다는 뜻이므로 이는 1 x 10^2로 표현할 수 있다.  
마찬가지로 20은 올림이 1번 발생한 수이다. 자리 올림이 1번 발생한 수가 2묶음 있다는 뜻이므로 이는 2 x 10^1로 표현할 수 있다.  
마지막으로 3은 올림이 0번 발생한 수이다. 자리 올림이 0번 발생한 수가 3묶음 있다는 뜻이므로 이는 3 x 10^0으로 표현할 수 있다.  

따라서 123은:

> 1 * 10^2 + 2 * 10^1 + 3 * 10^0

과 같이 표현할 수 있다.  

이 과정을 역으로 하려면 10으로 123을 나누는 방법이 있다.  
10을 나눈 나머지를 생각하며 다음 과정을 생각해보자.  

123 % 10 = 몫 12, 나머지 3  
12 % 10 = 몫 1, 나머지 2  
1 % 10 = 몫 0, 나머지 1  

이 나머지를 역순으로 취합해보면 123이라는 숫자가 등장한다.  

이 맥락에서 N진법을 이해하면 된다. 2진법은 두 개가 되면 올림이 발생함을 의미한다. 따라서 우리가 친숙한 0, 1, 2, 3, 4는 다음과 같다.  

|이진수|십진수|
|-|-|
|0b|0|
|1b|1|
|10b|2|
|11b|3|
|100b|4|

이진수의 뒤에 b를 붙인 이유는 10진수와 구분하기 위한 것이며 binary의 앞글자 b이다.  

## 2.1. 10진법 <-> 2진법 변환

앞에서 사용한 123을 이진법으로 표현해보자.  
기억하자. 이진수는 2가 될 때마다 자리 올림이 발생한다.  
10으로 나눈 나머지를 취합해 원래의 숫자를 파악한 것과 같은 원리로 이진수로 변환해볼 것이다.  

123 % 2 = 몫 61, 나머지 1  
61 % 2 = 몫 30, 나머지 1  
30 % 2 = 몫 15, 나머지 0  
15 % 2 = 몫 7, 나머지 1  
7 % 2 = 몫 3, 나머지 1  
3 % 2 = 몫 1, 나머지 1  
1 % 2 = 몫 0, 나머지 1  

이를 역순으로 취합해보면 1111011b라는 결과가 얻어진다.  

# 3. 음수를 표현하는 방법

앞에서 양수를 표현하는 방법에 대해서는 이미 배웠다. 이제는 음수를 표현해봐야 한다.  

6에서 1을 빼면 5라는 것은 누구나 알 고 있다. 이를 이진수로 변경해서 생각해보자.  

```text
 110b(6)
-001b(1)
-----
 101b(5)
```

각 수의 첫째자리는 0과 1이다. 0은 1을 뺄 수 없으므로 10진수에서 계산 할 때 위의 자리에서 10을 빌려와서 뺴는 것 과 같이, 이진수에서는 2를 빌려와서 뺀다. 따라서 2-1이기 때문에 첫째자리는 1이 되고, 둘 째자리는 값을 빌려주었기 때문에 0이되어 최종적으로 101b가 된다.  

이것이 가능한 이유는 우리가 사람이고 종이가 있어서 가능한 것이고, 컴퓨터를 설계했던 사람들이 해야 했던 고민은 `한정된 공간(즉, 메모리)`에서 이진수로 어떻게 음수를 표현하고 연산해야하는지에 대한 고민이 있었다.  

따라서 한정된 공간인 `메모리`에서 음수를 어떻게 표현하는지 공부해보자.  

## 3.1. 1의 보수를 사용하기

수를 저장하기 위한 공간이 8비트뿐이라고 가정해보자.  
그리고 다음과 같이 약속을 하자.  

- 음수로 만드려는 수의 비트를 반전 시킨 것이 음수

예를들어서 6이라는 숫자는 00000110b이다. 따라서 -6은 이를 반전시킨 
11111001b가 된다.  

비트를 반전 시킬 때 2^N - 1, 즉 1이 N개 채워진 비트에서 음수로 만들 수를 빼면 나오는 것을 구하는 것이다.  

우리의 경우에는 8비트가 주어져있고 -6을 구한다고 했을 때 과정은 다음과 같다.  

```text
11111111b
00000110b
---------
11111001b
```

6의 비트열을 1로 꽉채울 수 있는 수를 음수로 약속한 것이기 때문에 1의 보수라고 부르는 것이다. 결과가 모든 비트를 반전시킨 것과 같기 때문에 마음 편하게 사용하면 된다.  

하지만 이 방법은 다음과 같은 문제를 해결할 때 문제가 생긴다.  

-6 + 10을 생각해보자.  

```text
  11111001 -6
+ 00001010 10
----------
 100000011 3
```

일단 문제점을 나열해보자.  

1. -6과 10을 더한 결과는 4인데 3이 등장함
2. 주어진 것은 8비트인데 자리올림(carry)이 발생함

이를 옳은 답으로 만들기 위해서는 1을 더해주어야 한다. 즉, 자리 올림이 발생하면 1을 더해주면 정답이 나온다는 의미이다.  

이를 `end around carry`라고 부른다.  

대신 회로에서는 덧셈을 수행할 때 캐리 여부를 판단하고 1을 추가적으로 더해주는 구성을 해야하기 때문에 불편한 면이 있다.  

하지만 이것이 전부일까?  

0의 문제가 있다. 0을 표현해보자.  

```text
00000000b
```

하지만 이를 반전시킨 것 또한 0이다. 이 정의대로라면 +0과 -0으로 0이 두 개 생긴 것이다.  

그러면 또 이를 처리하기 위한 것이 추가적으로 들어간다. 더 좋은 방법이 없을까?  

## 3.2. 2의 보수를 사용하기



# 4. 실수 표현 방법
# 5. 문자 표현