# 목차

- [목차](#목차)
- [이론1 - 수와 타입](#이론1---수와-타입)
- [1. CPU와 메모리](#1-cpu와-메모리)
- [2. 컴퓨터의 수 표현](#2-컴퓨터의-수-표현)
  - [2.1. 10진법 <-> 2진법 변환](#21-10진법---2진법-변환)
- [3. 음수를 표현하는 방법](#3-음수를-표현하는-방법)
  - [3.1. 1의 보수(Ones' complement)를 사용하기](#31-1의-보수ones-complement를-사용하기)
  - [3.2. 2의 보수(two's complement)를 사용하기](#32-2의-보수twos-complement를-사용하기)
- [4. 실수 표현 방법](#4-실수-표현-방법)
- [5. 문자 표현](#5-문자-표현)

# 이론1 - 수와 타입

지난 시간에 배운 것들의 이론적 배경을 이번 시간에 학습한다. 정리하지 않았던 값의 표현 범위, 정밀도, 유니코드 등에 대해 학습할 것이다. 지루한 편이므로 가벼운 마음으로 듣자.  

여기서 학습할 내용은 다음과 같다.  

1. CPU와 메모리
2. 진법
3. 2의 보수
4. 실수 표현 방법
5. 문자표현

하나하나 알아보자.  

# 1. CPU와 메모리

CPU와 메모리의 역할에 대해서 간단히 다룬다.  

# 2. 컴퓨터의 수 표현

사람은 열 손가락을 이용해 숫자를 셀 수 있다. 우리가 다루는 숫자의 특징을 생각해보자. 열 개가 되면 (자리)올림이 발생한다.  

숫자 123을 생각해보자.  

100은 올림이 2번 발생한 수이다. 자리 올림이 2번 발생한 수가 1묶음 있다는 뜻이므로 이는 1 x 10^2로 표현할 수 있다.  
마찬가지로 20은 올림이 1번 발생한 수이다. 자리 올림이 1번 발생한 수가 2묶음 있다는 뜻이므로 이는 2 x 10^1로 표현할 수 있다.  
마지막으로 3은 올림이 0번 발생한 수이다. 자리 올림이 0번 발생한 수가 3묶음 있다는 뜻이므로 이는 3 x 10^0으로 표현할 수 있다.  

따라서 123은:

> 1 * 10^2 + 2 * 10^1 + 3 * 10^0

과 같이 표현할 수 있다.  

이 과정을 역으로 하려면 10으로 123을 나누는 방법이 있다.  
10을 나눈 나머지를 생각하며 다음 과정을 생각해보자.  

123 % 10 = 몫 12, 나머지 3  
12 % 10 = 몫 1, 나머지 2  
1 % 10 = 몫 0, 나머지 1  

이 나머지를 역순으로 취합해보면 123이라는 숫자가 등장한다.  

이 맥락에서 N진법을 이해하면 된다. 2진법은 두 개가 되면 올림이 발생함을 의미한다. 따라서 우리가 친숙한 0, 1, 2, 3, 4는 다음과 같다.  

|이진수|십진수|
|-|-|
|0b|0|
|1b|1|
|10b|2|
|11b|3|
|100b|4|

이진수의 뒤에 b를 붙인 이유는 10진수와 구분하기 위한 것이며 binary의 앞글자 b이다.  

## 2.1. 10진법 <-> 2진법 변환

앞에서 사용한 123을 이진법으로 표현해보자.  
기억하자. 이진수는 2가 될 때마다 자리 올림이 발생한다.  
10으로 나눈 나머지를 취합해 원래의 숫자를 파악한 것과 같은 원리로 이진수로 변환해볼 것이다.  

123 % 2 = 몫 61, 나머지 1  
61 % 2 = 몫 30, 나머지 1  
30 % 2 = 몫 15, 나머지 0  
15 % 2 = 몫 7, 나머지 1  
7 % 2 = 몫 3, 나머지 1  
3 % 2 = 몫 1, 나머지 1  
1 % 2 = 몫 0, 나머지 1  

이를 역순으로 취합해보면 1111011b라는 결과가 얻어진다.  

# 3. 음수를 표현하는 방법

앞에서 양수를 표현하는 방법에 대해서는 이미 배웠다. 이제는 음수를 표현해봐야 한다.  

6에서 1을 빼면 5라는 것은 누구나 알 고 있다. 이를 이진수로 변경해서 생각해보자.  

```text
 110b(6)
-001b(1)
-----
 101b(5)
```

각 수의 첫째자리는 0과 1이다. 0은 1을 뺄 수 없으므로 10진수에서 계산 할 때 위의 자리에서 10을 빌려와서 뺴는 것 과 같이, 이진수에서는 2를 빌려와서 뺀다. 따라서 2-1이기 때문에 첫째자리는 1이 되고, 둘 째자리는 값을 빌려주었기 때문에 0이되어 최종적으로 101b가 된다.  

이것이 가능한 이유는 우리가 사람이고 종이가 있어서 가능한 것이고, 컴퓨터를 설계했던 사람들이 해야 했던 고민은 `한정된 공간(즉, 메모리)`에서 이진수로 어떻게 음수를 표현하고 연산해야하는지에 대한 고민이 있었다.  

따라서 한정된 공간인 `메모리`에서 음수를 어떻게 표현하는지 공부해보자.  

## 3.1. 1의 보수(Ones' complement)를 사용하기

수를 저장하기 위한 공간이 8비트뿐이라고 가정해보자.  
그리고 다음과 같이 약속을 하자.  

- 음수로 만드려는 수의 비트를 반전 시킨 것이 음수

예를들어서 6이라는 숫자는 이진수로 표현하면 00000110b이다. 따라서 -6은 이를 반전시킨 11111001b가 된다.  

비트를 반전 시킬 때 2^N - 1, 즉 1이 N개 채워진 비트에서 음수로 만들 수의 절대값을 빼면 나오는 결과를 구하는 것이다.  

우리의 경우에는 8비트가 주어져있고 -6을 구한다고 했을 때 과정은 다음과 같다.  

```text
  11111111b # 1로 채움
- 00000110b # -6의 절대값 6의 이진수
-----------
  11111001b
```

8비트이므로 8자리수의 비트를 1로 채운 상태에서 -6의 절대값인 6을 뺀다. 이와 같이 6의 이진수 비트열을 1로 꽉채우기 위해 필요한 수를 음수로 취급한다는 의미를 갖기 때문에 1의 보수라는 이름이 붙어 있다. 이는 모든 비트를 0은 1로, 1은 0으로 반전 시킨 것과 결과가 동일하다. 따라서 1의 보수를 구할 때에는 위와 같은 설명을 위한 절차가 필요 없이 비트를 편하게 반전시키자.  

하지만 이 방법은 다음과 같은 문제를 해결할 때 문제가 생긴다.  

-6 + 10을 생각해보자.  

```text
  11111001b # -6
+ 00001010b # 10
-----------
 100000011b # 3
```

일단 문제점을 나열해보자.  

1. -6과 10을 더한 결과는 4인데 3이 등장함
2. 주어진 것은 8비트인데 자리올림(carry)이 발생함

이를 옳은 답으로 만들기 위해서는 1을 더해주어야 한다. 즉, 자리 올림이 발생하면 1을 더해주면 정답이 나온다는 의미이다.  

이를 `end-around carry`라고 부른다.  

대신 회로에서는 덧셈을 수행할 때 캐리 여부를 판단하고 1을 추가적으로 더해주는 구성을 해야하기 때문에 불편한 면이 있다.  

하지만 이것이 전부일까?  

0의 문제가 있다. 0을 표현해보자.  

```text
00000000b
```

하지만 이를 반전시킨 11111111b 또한 0이다. 이 정의대로라면 +0과 -0으로 0이 두 개 생긴 것이다.  

그러면 또 이를 처리하기 위한 회로가 추가적으로 들어간다. 더 좋은 방법이 없을까?  

## 3.2. 2의 보수(two's complement)를 사용하기

음수를 표현하는 방법 중 하나인 2의 보수를 공부해보자.  

2의 보수를 구하는 방법은 표현할 수 있는 비트 자리 수를 N이라 할 때, 2의 N승에서 구하려는 음수의 절대값을 뺀 수를 의미한다.  

앞의 가정과 동일하게 8비트 공간이 주어진 경우 -6에 대한 2의 보수를 구해보자.  

일단 자리수가 8비트이므로 2의 8승을 구한 후, -6의 절대값인 6을 뺀다.  
2의 8승은 256(100000000b)이고 6(00000110b)을 빼면 250이므로 11111010b가 -6을 의미한다. 이를 입증하기 위해 6과 -6을 더해보자.  

```text
  11111010b # -6
+ 00000110b # 6
-----------
  00000000b # 0
```

깔끔하게 결과가 나온다. 앞선 예제였던 -6 + 10도 해보자.  

```text
  11111010b # -6
+ 00001010b # 10
-----------
1|00000100  # 4
```

자리 올림이 발생하긴 했지만 8비트로 제한된 공간이므로 결과는 4가된다. 앞선 1의 보수로 음수를 표현하는 방법과 달리 `end-around carry`를 해줄 필요가 없다.  

2의 보수를 구하는 더 간단한 방법이 있다.  

1. 1의 보수를 구한다(모든 비트 반전)
2. 1을 더한다.

이렇게 하면 더 쉽게 구할 수 있다. 음수를 구할 때 이와 같이 비트 반전 후  1을 더하는 것이 유일하게 추가적으로 할 일이기 때문에 컴퓨터는 이 방식(2의 보수)으로 음수를 표현하는 방법을 차용하였다.  

1의 보수에서 `end-around carry`처리와 `0이 두 개로 표현`되는 것을 처리해야한다는 것을 생각해보면 훨씬 더 좋은 방법이다.  

참고로 -1을 2의 보수로 표현해보면 11111111b이다. 즉 0이 두 개가 아니라는 점 또한 장점이다.  

자바 코드로 이를 증명해볼 수 있을까?  

127의 2진수 값은 01111111b이다.  
128의 2진수 값은 10000000b이다.  

이 둘을 더하면 8비트 메모리 공간은 11111111b로 1로 꽉차게 될 것이다. 그리고 이는 곧 -1을 의미한다.  

따라서 127과 128을 더한 후 1바이트(8비트)만큼 자르면 된다. 이에 적합한 친구는 byte 타입이 있다.  

```java
int number = 127 + 128;
byte result = (byte) (number);
System.out.println(result);
System.out.println(number);
```

-1이 출력되었다. 밑에 있는 친구는 255를 출력한다. 이로써 여러분은 두 가지 사실을 확인할 수 있다.  

1. 컴퓨터에서 음수 표현은 2로 표현한다.
2. 컴퓨터의 숫자 표현은 저장된 형태에 따라 결정되는 것이 아니다. 해석하는 방법에 따라 결정된다.  

# 4. 실수 표현 방법

부동 소수점 설명

# 5. 문자 표현

아스키, 유니코드 설명