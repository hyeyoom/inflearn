# 목차

- [목차](#목차)
- [연습4 - 변하는 값을 담는 방법](#연습4---변하는-값을-담는-방법)
- [1. 해보자](#1-해보자)
- [1.1. 데이터의 종류](#11-데이터의-종류)
    - [1.1.1. 정수](#111-정수)
    - [1.1.2. 실수](#112-실수)
    - [1.1.3. 문자](#113-문자)
    - [1.1.4. 논리](#114-논리)
  - [1.2. 값 담아보기](#12-값-담아보기)
    - [1.2.1. 변수 이름(식별자) 명명 규칙](#121-변수-이름식별자-명명-규칙)
    - [1.2.2. 변수 선언](#122-변수-선언)
- [2. 더 해보자](#2-더-해보자)
- [3. 생각 해보기](#3-생각-해보기)
- [4. 레퍼런스](#4-레퍼런스)

# 연습4 - 변하는 값을 담는 방법

지난 시간에 배운 것에 대해 생각해보자.  

1. 이스케이프 시퀀스와 이스케이프 문자 종류
2. 주석

이번 시간에는 `exer4`라는 이름의 패키지를 생성하고, `Exercise4`라는 이름의 클래스를 생성해서 실습을 준비해보자.  

# 1. 해보자

한 번 현재 시간(시/분)을 출력해보자!  

```text
21시 15분
```

다음 코드를 읽지 않고 여러분이 각자 해보길 바란다.  

```java
LocalDateTime now = LocalDateTime.now();
int hour = now.getHour();
int minute = now.getMinute();
System.out.printf("%d시 %d분\n", hour, minute);
```

아마 여러분의 코드는 이런 형태였을 것이다.  

```java
System.out.println("21시 14분");
```

물론 상관은 없다. 하지만 시간이 바뀔 때 마다 코드를 수정해주어야 할 것이다. 처음에 제시한 코드는 그럴 필요가 없다. hour와 minute는 **변하는 수**이기 때문이다.  

이제 변하는 수, 즉 변수의 필요성은 이해했으니 선언하는 방법에 대해 알아보자.  

```text
데이터_종류 변수_이름;
데이터_종류 변수_이름 = 값;
```

이름이야 어떻게든 지을 수 있겠지만 데이터의 종류에 대해 모르는 상태이므로 데이터의 종류에 대해 공부해보자.  

# 1.1. 데이터의 종류

사실 데이터의 종류는 여러분이 이미 간접적으로 공부를 한 적이 있다. 눈치가 빠른 타입이라면 이미 리터럴을 공부했을 때 깨달았을 것이다. 앞서 배웠던 리터럴의 종류인 정수, 실수, 문자, 문자열, 논리 리터럴에 대해 다시 한 번 정리할 것이다.  

정리에 앞서 참고할 것이 있는데 정수, 실수, 문자, 논리 데이터의 타입을 `원시 타입(Primitive type)`이라고 부른다. 그 외에는 `참조 타입(Reference type)`이라고 부르는데 이는 뒤에 소개할 예정이다.  

정리하자. 데이터 타입의 종류는 크게 두 가지로 분류할 수 있다.  

> 타입 분류  
> 1. 원시 타입  
> 2. 참조 타입  
> 
> 원시 타입의 종류: 정수, 실수, 문자, 논리

문자열이 빠져있는 것을 눈치 챘다면 눈썰미가 굉장히 좋은 것이다. **문자열은 참조 타입**이다.  

이제 정리해보자.  

### 1.1.1. 정수

정수 타입의 데이터 타입은 값의 표현 범위에 따라 여러 종류가 존재한다. 표현 범위는 메모리 공간의 크기에 따라 결정된다. 공부해보자.  

|데이터 타입|표현 범위(바이트 수)|
|-|-|
|byte|-128 ~ 127(1)|
|short|-32,768 ~ 32767(2)|
|int|-2^31 ~ 2^31 - 1(4)|
|long|-2^63 ~ 2^63(8)|

### 1.1.2. 실수

실수 타입은 다른 타입들과 달리 정밀도라는 개념이 존재한다.  

|데이터 타입|표현 범위(바이트 수)|
|-|-|
|float|single precision(4)|
|double|double precision(8)|

단정밀도(single precision)은 소수점 6자리 까지, 배정밀도(double precision)은 소수점 12자리까지 정밀하다. 이 내용은 다음 시간에 자세히 다루도록 할 것이다.  

### 1.1.3. 문자

문자 타입은 다른 타입들과 달리 16비트(2바이트) 유니코드 문자를 저장한다.  

|데이터 타입|표현 범위(바이트 수)|
|-|-|
|char|유니코드(2)|

### 1.1.4. 논리

논리 타입은 다른 타입들과 달리 사이즈에 대한 정의는 딱히 된 것이 없고 true/false이다.  

|데이터 타입|표현 범위(바이트 수)|
|-|-|
|boolean|true나 false|

## 1.2. 값 담아보기

값을 담아보기 위해 앞서 소개한 내용을 다시 상기시켜보자.  

```text
데이터_종류 변수_이름;
데이터_종류 변수_이름 = 값;
```

이것이 바로 `변수 선언` 방법이다.  

이제 여러분은 데이터의 종류에 대해서는 배웠다. 변수 이름을 짓는 규칙들에 대해서 배워보고 값을 담아보자.  

### 1.2.1. 변수 이름(식별자) 명명 규칙

1. 변수 이름은 통화 기호($), 언더스코어(_) 그리고 알파벳(대소문자 모두)으로 시작함
2. 첫 번째 문자를 제외하곤 알파벳, 숫자, 언더스코어, 통화기호가 자유롭게 올 수 있음
3. 키워드는 식별자로 사용할 수 없음  
4. 식별자는 대소문자구분 함

### 1.2.2. 변수 선언

이제 실제로 변수를 선언하고 사용해보자.  

```java
// 정수 리터럴을 저장하는 데이터 타입들
byte b = 127;
short s = 32767;
int i = 2147483647;
long l = 9223372036854775807L;
System.out.println(b);
System.out.println(s);
System.out.println(i);
System.out.println(l);

// 실수 리터럴을 저장하는 데이터 타입들
float f = 3.141592653589793238462643f;
double d = 3.141592653589793238462643;
System.out.println(f);
System.out.println(d);

// 문자 리터럴을 저장하는 데이터 타입들
char c = '가';
System.out.println(c);

// 논리 리터럴을 저장하는 데이터 타입들
boolean b = true;
System.out.println(b);
```

리터럴을 그대로 출력했던 것과 같이 변수 이름을 사용해서 출력할 수 있다.  

변수를 사용하면 생기는 장점은 다음과 같다.  

1. 이름으로 부를 수 있다.
2. 고정 된 값이 아니라 변하는 값이다.

# 2. 더 해보자

이름으로 부를 수 있다는 점에서는 굉장히 유용하다는 것은 파악했다. 하지만 값이 변한다는 점이 마음에 걸린다. 변하지 않는 값도 이름으로 불러주면 개발할 때 좀 더 편할 것 같다.  

이를 `상수`라고 하는데 선언하는 방법은 다음과 같다.  

```java
final 데이터_종류 변수_이름 = 값;
```

`final` 키워드를 맨 앞에 붙여주면 된다. 또한 반드시 값을 할당해주어야 한다.  

```java
final double PI = 3.1415926535;
```

보통 이러한 상수의 이름은 대문자로 한다. 이는 자바의 규칙(rule)은 아니지만 관례(convention)이기 때문에 따르는 것이 프로그래밍을 할 때 더 편하다.  

물론 멋대로 해도 상관은 없는데 겪게될 불편은 본인이 감당하면 된다.  

# 3. 생각 해보기

자, 오늘 공부한 것을 정리해보자.  

1. 데이터 타입은 크게 두 가지로 분류된다.  
   - 원시 타입(Primitive type)
   - 참조 타입(Reference type)
2. 원시 타입에는 다음과 같은 것들이 있다.  
   - 정수: byte(1), short(2), int(4), long(8)
   - 실수: float(4), double(8)
   - 문자: char(2)
   - 논리: boolean
3. 변수 이름(식별자) 명명규칙
4. 상수 선언을 위한 키워드 final

# 4. 레퍼런스

https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html